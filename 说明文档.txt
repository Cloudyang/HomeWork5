1  每个人要学会做几个菜，不低于3个。。。先不用任何工厂方法，普通实现，分别展示几个菜，好不好吃
任务设计部署结构：类库IModel用于存放基类、抽象类、接口， 类库FirstModel用于存放实现类
1、在IModel开设First文件夹先定义抽象菜肴类AbstactDish，人类Person 人要吃饭，Person与基于AbstactDish类是组合关系

2  用简单工厂实现客人点菜，而不是让客人自己做菜(文字说明：如果要加一个菜，需要修改什么，考虑下简单工厂的长处和短处)
设计代码：抽象类与实现细节还是借用First，简单工厂实现方式详见SecondModel.FoodSimpleFactory类
长处：让上端不在依赖细节，将实现细节封装在简单工厂内实现。方便上端调用
短处：新增新类型时，需要变更简单工厂实现，简单工厂模式难以扩展

3  用工厂方法实现客人点菜，而不是让客人自己做菜(文字说明：如果要加一个菜，需要修改什么，考虑下工厂方法的长处和短处)
设计代码：抽象类与实现细节还是借用First，工厂方法详见命名空间SecondModel.Factory
长处：弥补了简单工厂的不足,让工厂实现便于扩展，符合开放封闭原则
短处：每个具体工厂类只完成单个实例的创建,工厂实现过于分散，没有形成一系列产品特性


4  用抽象工厂，每个工厂都能做三个菜、一个汤、一个主食，(文字说明：如果要加一个粥或者一个工厂，需要修改什么，考虑下抽象工厂的长处和短处)
设计代码：抽象类与实现细节还是借用First(三个菜)，详见命名空间IModel.AbstractFactory,具体实现类库ThridModel
长处：抽象工厂模式却可以很好地解决一系列产品创建的问题
短处：抽象工厂对添加新产品不支持，会破坏原有封装定义。这是因为抽象工厂接口已确定

5  做个点菜系统，用户输入可选菜id进行点菜：
设计代码：抽象的父类AbstractFood放在命名空间IModel.Fifth下，实现类放在解决方案FifthModel文件夹下,点菜系统通过OrderDishes类来实现。
多线程演示：甲乙丙三个客人(三个线程)分别随机点5个菜，然后每个菜依次做菜、品尝、点评 详见Client类

扩展要求 6  试着在5的基础上，为菜建立一个装饰器模式，装饰做菜方法
设计代码：在IModel.Fifth下增加BaseFood类，装饰器实现类详见FoodDecorator类库，
在点菜系统菜单选择后，已加入做菜前增加买菜、洗菜、切菜；做菜后增加摆盘、上菜；

错误提示：“Homework5.Client”的类型初始值设定项引发异常。或者 “Homework5.OrderDishes”的类型初始值设定项引发异常。
解决方案：请将TomatoScrambledEggs.dll、Vegatable.dll、Fish.dll等实体类拷贝到Homework5\Homework5\bin\Debug目录下。