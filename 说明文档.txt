1  每个人要学会做几个菜，不低于3个。。。先不用任何工厂方法，普通实现，分别展示几个菜，好不好吃
任务设计部署结构：类库IModel用于存放基类、抽象类、接口， 类库FirstModel用于存放实现类
1、在IModel开设First文件夹先定义抽象菜肴类AbstactDish，人类Person 人要吃饭，Person与基于AbstactDish类是组合关系

2  用简单工厂实现客人点菜，而不是让客人自己做菜(文字说明：如果要加一个菜，需要修改什么，考虑下简单工厂的长处和短处)
设计代码：抽象类与实现细节还是借用First，简单工厂实现方式详见SecondModel.FoodSimpleFactory类
长处：让上端不在依赖细节，将实现细节封装在简单工厂内实现。方便上端调用
短处：新增新类型时，需要变更简单工厂实现，简单工厂模式难以扩展

3  用工厂方法实现客人点菜，而不是让客人自己做菜(文字说明：如果要加一个菜，需要修改什么，考虑下工厂方法的长处和短处)
设计代码：抽象类与实现细节还是借用First，工厂方法详见命名空间SecondModel.Factory
长处：弥补了简单工厂的不足,让工厂实现便于扩展，符合开放封闭原则
短处：每个具体工厂类只完成单个实例的创建,工厂实现过于分散，没有形成一系列产品特性


4  用抽象工厂，每个工厂都能做三个菜、一个汤、一个主食，(文字说明：如果要加一个粥或者一个工厂，需要修改什么，考虑下抽象工厂的长处和短处)
设计代码：抽象类与实现细节还是借用First(三个菜)，详见命名空间IModel.AbstractFactory,具体实现类库ThridModel
长处：抽象工厂模式却可以很好地解决一系列产品创建的问题
短处：抽象工厂对添加新产品不支持，会破坏原有封装定义。这是因为抽象工厂接口已确定

5  做个点菜系统，用户输入可选菜id进行点菜：

    a)用单例模式生成菜单；

    b)菜单的可选菜用配置文件配置(单例菜单初始化的时候读取)；

    c)有一个抽象的父类AbstractFood,包含品尝普通方法、点评虚方法(随机评分)、做菜抽象方法,以及名称、价格、简介等基本属性(值最好也能放入到配置文件)；
    
    d)然后每个菜是一个独立的类，扩展新菜时可以增加dll，然后修改配置文件即可;

    e)用户输入id点菜，通过反射 + 简单工厂+ 配置文件去生成菜的对象；

    f)多线程演示：甲乙丙三个客人(三个线程)分别随机点5个菜，然后每个菜依次做菜、品尝、点评，

                  要求每个客人的五个菜吃完后，评选出该客人点的得分最高的菜，展示出来

                      三个客人都吃完后，评选出得分最高的菜，展示出来